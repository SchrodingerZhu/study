# 单子实例
## Reader

我们把`(->) a`类型的函子称为`Reader`函子，对应地也能给出单子的定义。`Reader`的应用函子作用是通过`<*>`向所连接的函数传递相同的参数然后传给一开始升格的函数得出最后的结果。

示例：
```haskell
input :: InputType
input = ...

let a = funcA input
    b = funcB input
    c = funcC input
in  final a b c

-- or

final <$> funcA <*> funcB <*> funcC $ input
```

在应用函子层面上，存在以下限制：
- 最终传入的升格函数的格式必须事先确定，且单个子函数直接数据不能互相依赖
- 不能中途对传入数据加以修改

因此，可以把`Reader`升级为单子的形式，这样可以提高灵活度。

```haskell
instance Monad ((->) a) where
    return = pure
    f >>= g = \x -> g (f x) x
```

考虑构建一个数据结构
```haskell
data MyStruct = MyStruct {
    foo :: String
,   bar :: String
,   zyf :: String
} deriving Show
```
同时有三个帮助加工字符串的函数，
```haskell
prepareFoo, prepareBar, prepareZYF :: String -> String
```
现在我们就可以书写出从一个字符串构造这个数据结构的方法：
```haskell
construct :: String -> MyStruct
construct = MyStruct <$> prepareFoo <*> prepareBar <*> prepareZYF 
```
使用单子可以写为
```haskell
construct' = do
    f <- prepareFoo
    b <- prepareBar
    z <- prepareZYF
    return $ MyStruct f b z 
```

为了方便使用，可以定义如下函数：
```haskell
ask :: a -> a
ask = id

local :: (a -> a) -> (a -> r) -> a -> r
local f g = g . f
```
第一个函数可以用在开头，显式的得出“全局参数”；第二个函数则可以用于在局部修改参数，如
```haskell
test = do 
    n <- ask
    f <- local (const "xxx") prepareFoo
    b <- prepareBar
    return $ MyStruct f b n
```
如果想把`local`影响的环境扩大，就在`local`后面加上一个子级`do-block`.

### 新类型形式
暂时忽略单子变换的问题，以直白的方式可以定义`Reader`为：
```haskell
newtype Reader r a = Reader {runReader :: r -> a}

instance Functor (Reader r) where
    fmap f m = Reader $ \r -> f (runReader m r)

instance Applicative (Reader r) where
    pure a = Reader $ \_ -> a
    f <*> x = Reader $ \r -> runReader f r $ runReader x r

instance Monad (Reader r) where
    return = pure
    m >>= k = Reader $ \r -> runReader (k (runReader m r)) r
```

## State
一般地，我们可以把一段程序看作一台转换状态的机器，输入一个初始状态，得到一个输出以及转换后的状态：
```haskell
stateA -> (output, stateB)
```
在其它语言中，我们把状态看成所有的全局变量的总和，程序每执行一步，就会对自身的状态做出更改。而在`haskell`中，单子也可以承载一段上下文，这样我们就可以专门抽象出一种单子来处理状态间的转移。

```haskell
newtype State s a = State { runState :: s -> (a, s) } 
```

作为函子

```haskell
instance Functor (State s) where
    fmap f fs = State $ \s ->
        let (a, s') = runState fs s
        in (f a, s')
```
大致过程就是转移状态，获得输出，加工输出，包裹回`State`

作为应用函子

```haskell
instance Applicative (State s) where
    pure a = State $ \s -> (a, s)
    f <*> fa = Sfate $ \s ->
        let (fab, s0) = runState f s
            (a, s1) = runState fa s0
        in (fab a, s1)
```

作为单子
```haskell
instance Monad (State s) where
    return = pure
    fa >>= f = State $ \s ->
        let (a, s') = runState fa s
        in runState (f a) s'
```

几个辅助函数
```haskell
get :: State s s
get = State $ \s -> (s, s)
-- 输出state本身


put :: s -> State s ()
put s = State $ \_ -> ((), s)
-- 直接放入state 

modify :: (s -> s) -> State s ()
modify f = State $ \s -> ((), f s)
-- 直接修改state

gets :: (s -> a) -> State s a
gets f = State $ \s -> (f s, s)
-- 按函数输出state

evalState :: State s a -> s -> a
evalState act = fst . runState act
-- 返回最终值

execState :: State s a -> s -> s
execState act = snd . runState act
-- 返回最终态
```

### 示例1
```haskell
module StateGame where

import Control.Monad.State

-- Example use of State monad
-- Passes a string of dictionary {a,b,c}
-- Game is to produce a number from the string.
-- By default the game is off, a C toggles the
-- game on and off. A 'a' gives +1 and a b gives -1.
-- E.g 
-- 'ab'    = 0
-- 'ca'    = 1
-- 'cabca' = 0
-- State = game is on or off & current score
--       = (Bool, Int)

type GameValue = Int
type GameState = (Bool, Int)

playGame :: String -> State GameState GameValue
playGame []     = do
    (_, score) <- get
    return score

playGame (x:xs) = do
    (on, score) <- get
    case x of
         'a' | on -> put (on, score + 1)
         'b' | on -> put (on, score - 1)
         'c'      -> put (not on, score)
         _        -> put (on, score)
    playGame xs

startState = (False, 0)

main = print $ evalState (playGame "abcaaacbbcabbab") startState
```

### 示例2
使用state计算a的个数
```haskell
countA :: String -> State Int Int
countA [] = get

countA (x:xs) = do
    case x of
        'a' -> modify (+1)
        _  -> modify id
    countA xs

-- evalState (countA "aaaa") $ 0
-- 4
```

## 



