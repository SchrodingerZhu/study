# 单子变换

## Kleisli
单子自身也可以构成一个范畴，叫做`Kleisli`范畴。这个范畴的特点是：
- return 是单位态射，对应`Hask`范畴的`id`
- `>=>` 是组合运算，对应`Hask`范畴的`.`

其中`>=>`的定义是
```haskell 
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
f >=> b = \x -> f x >>= g

(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)
f <=< g = flip (>=>)
```

## ReaderT

`Reader`单子的作用是注入全局参数，现在我们想用它包装其他单子，使得合成的新单子也拥有全局参数的功能，`ReaderT`就是为此而生

```haskell
newtype ReaderT r m a = ReaderT {runReaderT :: r -> m a}
```

可以看到`Reader`在`Hask`范畴上而`ReaderT`在`Kleisli`范畴上。

相关实例（注意内外层函数区别）：
```haskell
instance (Functor m) => Functor (ReaderT r m) where
    fmap f m = ReaderT $ \r -> fmap f (runReaderT m r)

instance (Applicative m) => Applicative (ReaderT r m) where
    -- pure :: a -> ReaderT r m a
    pure r = ReaderT $ \ _ -> pure r

    -- (<*>) :: ReaderT r m (a -> b) -> ReaderT r m a -> ReaderT r m b
    f <*> v = ReaderT $ \r -> runReaderT f r <*> runReaderT v r

instance (Monad m) => Monad (ReaderT r m) where
    -- return :: a -> ReaderT r m a
    return = pure
    -- (>>=) :: ReaderT r m a -> (a -> ReaderT r m b) -> ReaderT r m b
    m >>= k = ReaderT $\ r -> do
        a <- runReaderT m r
        runReaderT (k a) r

```

### 示例

```haskell
printEnv :: ReaderT String IO ()
printEnv = do
    ReaderT $ \env -> putStrLn ("Here' s " ++ env)

main :: IO ()
main = runReaderT printEnv "env"
```

观察`printEnv`，就是把读入的参数直接`print`出去，为了节省这种情况下的手动打包，定义函数：
```haskell
liftReaderT :: m a -> ReaderT r m a
liftReaderT m = ReaderT (const m)
```
以及类似`Reader`的辅助函数：
```haskell
ask :: Monad m => ReaderT r m r
ask = ReaderT return

local :: (r -> r)
    -> (ReaderT r m a)
    -> ReaderT r m a
local f m = ReaderT $ \r -> runReaderT m (f r)
```

新的使用示例：

```haskell
printEnv :: ReaderT String IO ()
printEnv = do
    env <- ask
    liftReaderT $ putStrLn ("Here is " ++ env)
    local (const "local env") $ do
        env' <- ask
        liftReaderT $ putStrLn ("Here is " ++ env')
```

# 未完待续