# 模板泛型

## 模板编程

### 简介

`lens`这个库中在`Control.Lens.HT`下提供了一个`makeLenses`函数，可以自动为写好的类型生成透镜组，这就用到了模板编程。

### AST
`haskell`内置了自己的`AST`定义，一些简单的部分包括：
```haskell
data Exp 
    = VarE Name -- 变量
    | ConE Name -- 构造函数
    | AppE Exp Exp -- 函数应用
    | InfixE (Maybe Exp) Exp (Maybe Exp) -- 中缀函数应用/Section语法
    | LitE Lit -- 字面量 
```

为了流畅的使用这些定义，需要引入`template-haskell`库以及`Language.Haskell.TH.Syntax`,并打开`TemplateHaskell`. 同时也就得到了很多辅助函数，如`mkName`就能够把`String`转换到`Name`.

在语法方面，主要注意：
- 在普通绑定前面加上`'`可以得到对应的`Name`，`'fmap = fmap :: Name`
- 在类型和类型类前面加上`''`可以得到对应的`Name`, `''Position = Position :: Name`

此外还有很多辅助定义：
- 类型
  ```haskell
    data Type = ForallT [TyVarBndr] Cxt Type  -- ^ @forall \<vars\>. \<ctxt\> -> \<type\>@
          | AppT Type Type                -- ^ @T a b@
          | SigT Type Kind                -- ^ @t :: k@
          | VarT Name                     -- ^ @a@
          | ConT Name                     -- ^ @T@
          | PromotedT Name                -- ^ @'T@

          -- See Note [Representing concrete syntax in types]
          | TupleT Int                    -- ^ @(,), (,,), etc.@
          | UnboxedTupleT Int             -- ^ @(#,#), (#,,#), etc.@
          | ArrowT                        -- ^ @->@
          | ListT                         -- ^ @[]@
          | PromotedTupleT Int            -- ^ @'(), '(,), '(,,), etc.@
          | PromotedNilT                  -- ^ @'[]@
          | PromotedConsT                 -- ^ @(':)@
          | StarT                         -- ^ @*@
          | ConstraintT                   -- ^ @Constraint@
          | LitT TyLit                    -- ^ @0,1,2, etc.@
      deriving( Show, Eq, Data, Typeable )
  ```
- 模式
  ```haskell
  data Pat 
    = LitP Lit                      -- ^ @{ 5 or 'c' }@
    | VarP Name                     -- ^ @{ x }@
    | TupP [Pat]                    -- ^ @{ (p1,p2) }@
    | UnboxedTupP [Pat]             -- ^ @{ (# p1,p2 #) }@
    | ConP Name [Pat]               -- ^ @data T1 = C1 t1 t2; {C1 p1 p1} =    e@
    | InfixP Pat Name Pat           -- ^ @foo ({x :+ y}) = e@
    | UInfixP Pat Name Pat          -- ^ @foo ({x :+ y}) = e@
                                    --
                                    -- See    "Language.Haskell.TH.Syntax#infix"
    | ParensP Pat                   -- ^ @{(p)}@
                                    --
                                    -- See    "Language.Haskell.TH.Syntax#infix"
    | TildeP Pat                    -- ^ @{ ~p }@
    | BangP Pat                     -- ^ @{ !p }@
    | AsP Name Pat                  -- ^ @{ x \@ p }@
    | WildP                         -- ^ @{ _ }@
    | RecP Name [FieldPat]          -- ^ @f (Pt { pointx = x }) = g x@
    | ListP [ Pat ]                 -- ^ @{ [1,2,3] }@
    | SigP Pat Type                 -- ^ @{ p :: t }@
    | ViewP Exp Pat                 -- ^ @{ e -> p }@
    deriving( Show, Eq, Data, Typeable )
  ```