# 类型定义相关语法

## type 别名
```haskell
type List a = [a]
type IntList = [Int]
```
`type`只是创建别名，并不会创建新类别

## newtype 新类别
```haskell
newtype Inch = Inch Double deriving Eq
newtype State s a = State {
    runState :: s -> (s, a)
}
```

`newtype`相比`data`少了类型标签，效率更高

## Bottom
在Prelude中`undefined`代表底类型，即无法计算的值(`_|_`)

## Uboxed
```haskell
Int#
Array#
```
这种`#`表示没有被打包的类型。常用于底层操作。很多相应的类型定义在`GHC.Exts`和`GHC.Prim`中

### UnboxedTuples
编译器选项`UnboxedTuples`引入`UnboxedTuples`，语法如下：
```haskell
(# e_1, ..., e_n #)
```

### UnboxedSums
编译器选项`UnboxedSums`引入非打包带`Sum Type`，语法如下：
```haskell
(# t_1 | t_2 | ... | t_N #)
```

### MagicHash
编译器选项`MagicHash`可以放开`#`语法的限制，在操作`Unboxed`类型是需要开启。

## Data.Coerce
`newtype`定义的类型有时可以理解为和底层类型是等价的，`Coercible`则提供了这样的类型互转的功能。

```haskell
class Coercible a b
```

这个定义就是描述了`a`, `b`底层相同

```haskell
coerce :: Coercible * a b => a -> b
```

这个函数则是用来转换类型的。

需要注意的`Coerce`的示例是自动识别的，不需要手动添加，也不允许手动添加。

系统推导时会有这样一个定义
```haskell
instance Coercible a a
instance Coercible a T => Coercible a NT
instance Coercible T b => Coercible NT b

instance Coercible b b' => Coercible (D a b c) (D a b' c')
```
前三个规则都很好理解，最后一个其实描述了类型地位的概念，`Haskell`类型分为：
- nominal 主类型
- representational 表象类型
- phantom 幻影类型

这三个类型和`abc`分别对应，推导规则是：
- 主类型相同
- 表象类型`Coercible`
- 幻影类型任意

手动更改类型地位：
```haskell
data Set a = ...
type role Set nominal
```

其他库中常用运算符：
```haskell
(#.) :: Coercible b c => (b -> c) -> (a -> b) -> (a -> c)
(#.) f = coerce
```