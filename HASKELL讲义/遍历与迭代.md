# 遍历和迭代
![](https://wiki.haskell.org/wikiupload/thumb/3/39/FunctorHierarchy.svg/1116px-FunctorHierarchy.svg.png)
## Foldable
`Data.Foldable`中定义了该类型类 
```haskell
class Foldable where
    fold :: Monoid m => t m -> m --合并
    foldMap :: Monoid m -> (a -> m) -> t m -> m -- 先变换再合并
    foldr :: (b -> a -> b) -> b -> t a -> b
    foldl :: (b -> a -> b) -> b -> t a -> b
    foldr' :: (b -> a -> b) -> b -> t a -> b
    foldl' :: (b -> a -> b) -> b -> t a -> b
    foldr1 :: (a -> a -> a) -> t a -> a
    foldl1 :: (a -> a -> a) -> t a -> a
    toList :: t a -> [a]
    null :: t a -> Bool --是否为空
    length :: t a -> Int
    elem :: Eq a => a -> t a -> Bool --是否在集合中
    maximum :: Ord a => t a -> a -- 最大元素
    minimum :: Ord a => t a -> a -- 最小元素
    sum :: Num a => t a -> a 
    product :: Num a => t a -> a
```
最小定义是`foldr`或者`foldMap`

`Foldable`和`Monoid`关系紧密，来看看`foldr`用`foldMap`的定义:
```haskell
foldr f z t = appEndo (foldMap (Endo #. f) t) z 
```

`f`是一个`a -> b -> b`的函数，考虑`Endo Monoid`定义，这里相当于把每个函数应用到容器元素中，得到半应用的函数，然后连接起来作用到`z`上。

反过来用`foldr`实现`foldMap`：
```haskell
    foldMap f = foldr (mappend . f) mempty
```

还有`foldl`的实现：
```haskell
foldl f z t = (appEndo $ getDual $ foldMap (Dual #. Endo #. (flip f)) t) z
```

## 未完待续