# 单子

## 意义
考虑表达式
```haskell
replicate <$> Just 5 <*> Just 12
```
- 当第一个参数为Nothing时，如果我们只想重复第二个元素一遍，在应用函子的帮助下是做到的
- 如果遇到
  ```haskell
  replicate' :: Maybe Int -> [Int]
  ```
  此类函数在再次升格时，会出现`Maybe (Maybe Int)`的类型

考虑到第二种情形，因为第二层一样的包装并无意义，如果能定义一种压缩包装的操作便可继续进行计算，这就是`join`
对于`Maybe`
```haskell
join :: Maybe (Maybe a) -> Maybe a
join (Just x) = x
join Nothing = Nothing 
```
对于列表
```haskell
join :: [[a]] -> [a]
join = concat
```

## 定义
```haskell
class Applicative m => Monad m where
    return :: a -> m a
    return = pure

    join :: m (m a) -> m a

    (>>=) :: m a -> (a -> m b) -> m b
    x >>= f = join $ fmap f x
```
`(>>=)`是一个非常有用的函数. 

`<*>`可以使用`(>>=)`重新实现
```haskell
(<*>) :: Monad m => m (a -> b) -> m a -> m b
mf <*> mx = join $ fmap (\f -> fmap f mx) mf
-- or
mf <*> mx = mf >>= (\f -> (mx >>= \x => f x))
```

几个列表结合`(>>=)`的示例：
```haskell
[1, 2, 3] >>= (\x -> [x, x^2, x^3])
-- [1, 1, 1, 2, 4, 8, 3, 9, 27]

[1..10] >>= \x ->
    [x..10] >>= \y ->
        return (x * y)
```
应用函子和单子最大的不同就是应用函子不能中途改变计算的上下文，而单子可以做到。

## bind
`(>>=)`即是所谓的粘合函数，可以和`join`互相推导
```haskell
join mmx = mmx >>= id
```
`join`和`(>>=)`同构。
此外，粘合函数还有以下性质：
- `return a >>= k == k a`
- `m >>= return == m`
- `m >>= (x -> (k x) >>= h) == (m >>= k) >>= h`

## do 语法糖
上面枚举乘法的表达式可以改写为
```haskell
enum = do
    x <- [1..10]
    y <- [x..10]
    return (x * y)
```
同样地，下面这两种写法等价：
```haskell
Just 3 >>= \n ->
    Just 'x' >>= \x ->
        replicate n x
-- or
do
    n <- Just 3
    x <- Just 'x'
    return $ replicate n x 
```

