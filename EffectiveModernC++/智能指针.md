# 智能指针

## std::auto_ptr历史

`std::auto_ptr`已经是弃用特性了，设计它的时候没有移动语义，导致了不能容器储存和复制时置空这些令人头疼的问题。还好到了`C++11`我们就有了`std::unique_ptr`.

## std::unique_ptr

一般情况下`std::unique_ptr`可以认为和裸指针占有相同大小的空间。这是一个**只移类型**。

一个常用的用法是在对象继承谱系中作为工厂函数的返回类别。

如果异常扩散影响到了主函数或者直接调用`std::_Exit`，`std::quick_exit`，`std::exit`的话`unique_ptr`会无法析构但是一般情形下是可以的自动处理的。可以使用函数、函数对象以及`lambda`表达式来指定自定义的析构函数，型别需要传递给第二个模板参数（可用`decltype`）。可以使用`reset`函数来为一个`unique_ptr`指定新的所有地址（例如，一开始使用了空指针初始化，后来再重新分配实例）。

一般的，在工厂函数返回指针时，创建对象可以对实参使用`std::forward`进行完美转发。

在使用了自定义析构函数后，`std::unique_ptr`占用的空间可能会上升，函数会上升一两个字长，函数对象取决于对象本身储存的状态，值得注意的是，**无捕获`lambda`是不会提升占用空间的**。

`std::unique_ptr`的数组形式`std::unique_ptr<T[]>`和`std::uniqe_pt<T>`是区别封装的，前者不能使用`operator*,operator->`后者不能使用`operator[]`.

`std::unique_ptr`另一个重要的特性就是它可以非常方便的转换到`std::shared_ptr`（一个赋值语句就可以）。

## std::shared_ptr

这是引用计数指针。构造递增，析构递减，复制同时。

性能影响：

- 尺寸为裸指针两倍。因为内部有裸指针也有引用计数使用的另一个裸指针（非标准要求，但大多如此实现）。
- 引用计数内存动态分配。`std::make_ptr`可以避免一定的动态分配成本，但不是所有场合都适用。
- 引用计数的增减必须原子化，造成读写成本较高。

·`std::shared_ptr`的传递采用移动，会置空原有引用计数指针。

不同的是，自定义析构函数的型别不再是模板参数，自定义析构器本身不增加引用计数指针的大小，而是在堆上分配了更多的空间，即在引用计数的控制块内包含析构器的复制。

控制块的创建规则如下：

- `std::make_shared`总是创建控制块。
- 从专属所有权指针构造时（`std::auto_ptr,std::unique_ptr`），会创建控制块。
- 以裸指针作为实参调用引用计数指针构造函数，会创建控制块。

因此，对一个裸指针多次创建引用计数指针是非常危险的，会产生多个控制块，导致未定义行为的发生。

把`this`指针传递到`std::shared_ptr`的容器里是非常不正确的做法，希望安全处理这种情况的话，应该让类继承`std::enable_shared_from_this<ClassName>`，这一设计模式称为**奇妙递归模板模式**。这一基类包含了一个`shared_from_this`函数，可以用于返回和`this`指代相同对象的引用计数指针。方式是查找当前对象的控制块，返回同控制块的计数指针。但是如果调用前没有计数指针存在，就会引发异常报错。因此，使用该基类的类往往以`private`模式封装自己的构造函数，并要求用户使用工厂函数来创建对象。

引用计数指针并没有单独封装数组，但是不建议使用引用计数指针指代数组指针。

## std::weak_ptr

`std::weak_ptr`不能提领，也不能检查计数，作为`std::shared_ptr`的扩充而存在。`std::weak_ptr`可以和引用计数指针指向同一对象而不影响其计数。
