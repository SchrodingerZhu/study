# 右值引用、移动语义与完美转发

**移动语义**：用移动操作代替复制操作以减少代价

**完美转发**：编写接受任意实参的模板函数再转发到接受对应实参的函数

永远记住：

```c++
void f(Foo&& bar);
```

函数的形参永远是左值，如上`bar`是左值，类型是指涉`Foo`的右值引用。

## std::forward与std::move

`std::move`不进行移动，`std::forward`不进行转发，两个函数在运行期没有任何对应的可执行代码，一个字节都没有。他们是用于强行类别转换的模板函数，`std::move`无条件转换，`std::forward`有条件转换。

这是一个简化般的`std::move`实现：

```c++
template <typename T>
typename remove_reference<T>::type&& move(T&& param) {
    using ReturnType = 
        typename remove_reference<T>::type&&;
    return static_cast<ReturnType>(param);
}
```

`remove_reference<T>::type&&`这一部分是为了保证即使在`T`是一个左值引用的时候，万能引用也能被转换成右值。简而言之，`std::move`就是把所有类型强转为右值。

但是右值不一定被移动，如现在你有了一个`std::string text`作为参数，传入一个接受`const std::string`的类构造函数，在初始列表中，采用`Foo(): value(std::move(text))`的方式赋值，结果最终还是进行了复制。

假设同时`string`有这样两个构造函数：

```c++
 string (const string& rhs);
 string (string&& rhs);
```

`const string`的右值是无法传递给移动构造函数的，所以最终编译器还是选择了第一个函数。

为了理解`std::forward`的用法，观察下面的代码：

```c++
void process(const Widget& lvalArg); // A
void process(Widget&& rvalArg);// B

template <typename T>
void logAndProcess(T&& param) {
    auto now =
        std::chrono::system_clock::now();
    makeLogEntry("Calling 'process'", now);
    process(std::forward<T>(param));
}

Widget w;

logAndProcess(w); // Call 1
logAndProcess(std::move(w)); // Call 2
```

这里第一条调用最终被转发到了`A`函数，第二条到了`B`函数，这就是`std::forward`的作用导致的：仅当其实参使用右值完成初始化时执行向右值的强制类型转换。（`std::forward`可以从模板参数`T`中提取到初始化的信息）。

## 万能引用与右值引用

```c++
void f(Widget&& param); // 右值引用

Widget&& var1 = Widget(); // 右值引用

auto&& var2 = var1; // 非右值引用

template <typename T>
void f(std::vector<T>&& param); //右值引用

template <typename T>
void f(T&& param); // 右值引用
    
```

万能引用具体对应什么类型的引用取决于初始化物。在模板类内部出现`T&&`类似语法也不能保证是万能引用，必须标注模板函数才能保证形如`T&&`的引用是万能引用。

用`C++14` 的`lambda`表达式来计算任意函数的调用时长：

```c++
auto timeFuncInvocation = 
    [](auto&& func, auto&&... params) {
    //计时开始
    std::forward<decltype(func)>(func) (
        std::forward<decltype(params)>(params)..
    );
    //停止计时
}
```

（更多关于引用折叠的知识将记录在后续章节.）











